#!/usr/bin/env bash

#
# OCP cluster orchestrator and benchmark job runner.
# See helper function (show_help|-h) for more information.
#

set -o pipefail
set -o nounset
set -o errexit

#
# Globals
#
declare -gx OPT_CMD
declare -gx OPT_WATCH
declare -gx RUN_TIMEOUT

declare -gxr PROG_NAME="openshift-provider-cert"
declare -gxr WORKDIR="./.openshift-cert"
declare -gxr STAT_FILE="${WORKDIR}/sonobuoy-status.json"
declare -gxr RESULTS_LATEST="${WORKDIR}/results-latest.txt"
declare -gxr STATUS_INTERVAL_SEC=10

sonobuoy_path="$(command -v sonobuoy)"
declare -gxr CMD_SONOBUOY="${sonobuoy_path}"

OPT_WATCH=false

mkdir -p "${WORKDIR}"

#
# Helper
#
show_help() {

    cat <<-EOF
Usage: ${0} command [options]
Available commands:
    help                        Show this help.
    run                         Run the suite of tests for provider certification.
    status                      Show the current status.
    retrieve                    Collect the results from Certification environment.
    results                     Read the results from the latest artifact file.
    destroy                     Destroy current Certification Environment.

Global options:
    -h | --help                 Show this help.

Available options for 'run':
    --timeout {number}          Optional. Timeout in minutes to
                                wait the execution. Default: 43200
    -w|--watch                  Optional. Keep watch status after running.

Available options for 'status':
    -w|--watch                  Optional. Keep watch status after running.


Examples:
    # Run the Certification tool
    ${0} run
    ${0} run -w

    # Check the current status
    ${0} status
    ${0} status -w

    # Collect the result artifacts
    ${0} retrieve

    # Show the results from the latest artifacts
    ${0} results

    # Destroy the certificate environment
    ${0} destroy

EOF

}

#
# cmd: status
#
check_sonobuoy_ns_exists() {
    if [[ -z "$(oc get projects |grep ^sonobuoy || true)" ]]; then
        echo -ne 1
    fi
    echo -ne 0
}

run_status_updater() {
    ${CMD_SONOBUOY} status --json > "${STAT_FILE}" 2>/dev/null || true
}

# show_status reads the .msg field from plugin object used to implement
# the serial execution. That field contains more details about the current
# state of plugin. It is not displayed by default on 'sonobuoy status'.
show_status() {
    run_status_updater
    printf "\n\n$(date)> Global Status: %s" "$(jq -r '.status // "Unknown"' ${STAT_FILE})"
    printf "\n%-30s | %-10s | %-10s | %-25s | %-50s" \
            "JOB_NAME" "STATUS" "RESULTS" "PROGRESS" "MESSAGE"
    for plugin_name in $(jq -r '.plugins[].plugin' ${STAT_FILE} |sort); do
        pl_status=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\").status" "${STAT_FILE}")
        pl_result=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\")[\"result-status\"]" "${STAT_FILE}" | tr -d '\n')

        pl_prog_total=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\").progress.total // \"\"" "${STAT_FILE}" | tr -d '\n')
        pl_prog_comp=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\").progress.completed // \"\"" "${STAT_FILE}" | tr -d '\n')
        pl_prog_failed=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\").progress.failures|length" "${STAT_FILE}" | tr -d '\n')

        pl_progress=""
        if [[ -n "${pl_prog_total}" ]]; then
            pl_progress="${pl_prog_comp}/${pl_prog_total} (${pl_prog_failed} failures)"
        fi

        pl_count_pass=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\")[\"result-counts\"].passed" "${STAT_FILE}" | tr -d '\n')
        pl_count_fail=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\")[\"result-counts\"].failed" "${STAT_FILE}" | tr -d '\n')
        test "${pl_count_pass}" == "null" && pl_count_pass=0
        test "${pl_count_fail}" == "null" && pl_count_fail=0

        if [[ "${pl_status}" == "running" ]]; then
            pl_msg=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\") |.progress.msg // \"\"" "${STAT_FILE}" | tr -d '\n')
        elif [[ "${pl_result}" == "" ]]; then
            pl_msg="waiting post-processor..."
        else
            pl_msg="Total tests processed: $(echo "$pl_count_pass + $pl_count_fail "|bc) (${pl_count_pass} pass / ${pl_count_fail} failed)"
        fi

        printf "\n%-30s | %-10s | %-10s | %-25s | %-50s" \
                "${plugin_name}" "${pl_status}" "${pl_result}" \
                "${pl_progress}" "${pl_msg}"
    done
    printf "\n\n"
}

# show_results_processor is used to display the post-processor counters available,
# after the plugins has been completed.
show_results_processor() {
    run_status_updater
    printf "\n\n$(date)> Global Status: %s" "$(jq -r '.status // "Unknown"' ${STAT_FILE})"
    printf "\n%-30s | %-10s | %-10s | %-50s" \
            "JOB_NAME" "STATUS" "RESULTS" "PROCESSOR RESULTS"
    for plugin_name in $(jq -r '.plugins[].plugin' ${STAT_FILE} |sort); do
        pl_status=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\").status" "${STAT_FILE}")
        pl_result=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\")[\"result-status\"]" "${STAT_FILE}" | tr -d '\n')

        pl_count_pass=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\")[\"result-counts\"].passed" "${STAT_FILE}" | tr -d '\n')
        pl_count_fail=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\")[\"result-counts\"].failed" "${STAT_FILE}" | tr -d '\n')
        test "${pl_count_pass}" == "null" && pl_count_pass=0
        test "${pl_count_fail}" == "null" && pl_count_fail=0

        pl_msg="Total tests processed: $(echo "$pl_count_pass + $pl_count_fail "|bc) (${pl_count_pass} pass / ${pl_count_fail} failed)"

        printf "\n%-30s | %-10s | %-10s | %-50s" \
                "${plugin_name}" "${pl_status}" \
                "${pl_result}" "${pl_msg}"
    done
    printf "\n\n"
}

cmd_status() {
    if [[ $(check_sonobuoy_ns_exists) -ne 0 ]]
    then
        echo "ERROR: Looks like there's not Certification environment running."
        echo "       Use the 'run' option to start the Certification process."
        exit 1
    fi
    run_status_updater
    # execution has the status=running
    if [[ "$(jq -r .status "${STAT_FILE}")" == "running" ]]
    then
        if [[ "${OPT_WATCH}" == true ]]
        then
            wait_for_jobs_running
        fi
        show_status
        exit 0
    fi
    # execution has the status=post-processing
    if [[ "$(jq -r .status "${STAT_FILE}")" == "post-processing" ]]
    then
        if [[ "${OPT_WATCH}" == true ]]
        then
            wait_for_post_processor
        fi
        show_results_processor
        exit 0
    fi
    # execution has the status=complete
    if [[ "$(jq -r .status "${STAT_FILE}")" == "complete" ]]
    then
        echo "The execution has been completed! Run '$0 retrieve' to collect the results."
        exit 0
    fi
    #TODO: check the other states
    echo "Unknown state [$(jq -r .status "${STAT_FILE}")]"
}
#
# cmd: results
#
cmd_results() {
    local file_path
    if [[ ! -f "${RESULTS_LATEST}" ]]
    then
        echo "ERROR: the result file[${RESULTS_LATEST}] was not found."
        exit 1
    fi
    file_path="${WORKDIR}/$(cat "${RESULTS_LATEST}")"
    if [[ ! -f "${file_path}" ]]
    then
        echo "ERROR: the artifact file[${file_path}] was not found."
        exit 1
    fi
    echo "#> Reading results from file ${file_path}"
    ${CMD_SONOBUOY} results "${file_path}"
}


cmd_retrieve() {
    collect_results
}

#
# cmd: destroy
#
check_sonobuoy_not_present() {
    # Check if there's sonobuoy environment: should fail
    if [[ -z "$(oc get projects |grep ^sonobuoy || true)" ]]; then
        echo "The namespace [sonobuoy] is not present on cluster. Ignoring..."
        exit 1
    fi
}

delete_sonobuoy_env() {
    ${CMD_SONOBUOY} delete --wait
}

delete_tests_namespaces() {
    sleep 10;
    echo "Removing non-openshift NS..."
    mapfile -t ns_to_delete < <(oc get projects |awk '{print$1}' |grep -vP '^(NAME)|(openshift)|(kube-(system|public|node-lease))|(default)' |sort -u || true)
    for project in "${ns_to_delete[@]}"; do
        echo "Stale namespace was found: [${project}], removing..."
        oc delete project "${project}" || true
    done
}

restore_scc() {
    echo "Restoring privileged environment..."
    oc adm policy remove-scc-from-group anyuid system:authenticated system:serviceaccounts || true
    oc adm policy remove-scc-from-group privileged system:authenticated system:serviceaccounts  || true
}

delete_sonobuoy_status() {
    echo "Removing status file"
    rm "${STAT_FILE}" || true
}

cmd_destroy() {
    echo "##> "
    echo "#> Starting destroy flow..."

    if [[ -n "$(oc get projects |grep ^sonobuoy || true)" ]]
    then
        delete_sonobuoy_env
        delete_sonobuoy_status
    fi

    delete_tests_namespaces
    restore_scc
    echo "Destroy Done!"
}

#
# cmd: run
#
check_sonobuoy_is_present() {
    if [[ $(check_sonobuoy_ns_exists) -eq 0 ]]
    then
        echo "ERROR: Looks like the Certification environment exists."
        echo "Run the 'destroy' option before starting new certification tests."
        exit 1
    fi
}

set_scc() {
    echo "Ensuring the Tool will run in the privileged environment..."
    oc adm policy add-scc-to-group anyuid system:authenticated system:serviceaccounts
    oc adm policy add-scc-to-group privileged system:authenticated system:serviceaccounts
}

run_default() {
    echo "Running OpenShift Provider Certification Tool..."
    # Do not use timeout=0:
    # https://github.com/mtulio/openshift-provider-certification/issues/17
    PLUGIN_TIMEOUT=${RUN_TIMEOUT:-43200}
    ${CMD_SONOBUOY} run \
        --dns-namespace=openshift-dns \
        --dns-pod-labels=dns.operator.openshift.io/daemonset-dns=default \
        --timeout="${PLUGIN_TIMEOUT}" \
        --plugin=tools/plugins/openshift-kube-conformance.yaml \
        --plugin=tools/plugins/openshift-provider-cert-level-1.yaml \
        --plugin=tools/plugins/openshift-provider-cert-level-2.yaml \
        --plugin=tools/plugins/openshift-provider-cert-level-3.yaml
    RC=$?
    if [[ ${RC} -ne 0 ]]; then
        echo "ERROR: error running the tool. Please check the errors and try again."
        exit ${RC}
    fi
}

wait_for_jobs_running() {
    echo "$(date)> The certification tool is running, statuses will be reported every minute..."
    sleep 5 # waiting to leave from 'Pending' state
    while true; do
        run_status_updater
        if [[ "$(jq -r .status "${STAT_FILE}")" != "running" ]]; then
            break
        fi
        show_status
        sleep "${STATUS_INTERVAL_SEC}"
    done
    show_status
    echo -e "\n\n$(date)> Jobs has finished."
    sleep 5
    show_results_processor
}

wait_for_post_processor() {

    echo -e "\nWaiting for post-processor..."
    cnt=0
    while true; do
        run_status_updater
        if [[ "$(jq -r .status "${STAT_FILE}")" != "post-processing" ]]; then
            break
        fi
        cnt=$(( cnt + 1 ))
        if [[ $cnt -eq 20 ]]; then
            echo -e "\n\n$(date)> Timeout waiting the result post-processor..."
            echo -e "\n\n$(date)> Run again with option 'check'"
            exit 1
        fi
        sleep "${STATUS_INTERVAL_SEC}"
    done
    echo -e "\nPost-processor has finished. The results can be collected!"
}

collect_results() {
    echo -e "\n\nCollecting results..."
    # TODO: Check if file available on "tar-info".name is present to
    #  avoid donwload twice.

    sleep 10
    set +o errexit
    download_failed=true
    retries=0
    while ${download_failed}; do
        result_file=$(sonobuoy retrieve)
        RC=$?
        if [[ ${RC} -eq 0 ]]; then
            download_failed=false
        fi
        retries=$(( retries + 1 ))
        if [[ $retries -eq 10 ]]; then
            echo "Retries timed out. Check 'sonobuoy retrieve' command."
            exit 1
        fi
        echo "Error retrieving results. Waiting 10s to retry...[${retries}/10]"
        sleep 10
    done
    set -o errexit

    if [[ -f ${result_file} ]]; then
        echo "Results saved at file ${result_file}"
        echo "Conformance runner has finished successfully."

        # Used by 'results'
        echo "${result_file}" > "${RESULTS_LATEST}"
        mv "${result_file}" "${WORKDIR}"/
        exit 0
    fi

    echo "Results file not found. Execution has finished with errors."
    exit 1
}

cmd_run() {
    echo "Starting OpenShift Provider Certification Tool..."

    check_sonobuoy_is_present
    set_scc
    run_default
    echo "Jobs scheduled!"
    if [[ "${OPT_WATCH}" == false ]]
    then
        echo "Collecting initial status..."
        show_status
        echo "You can check execution using 'status' option."
        echo "Example: $0 status -w"
        exit 0
    fi
    echo "Watcher flag detected! The status will be reported every ${STATUS_INTERVAL_SEC} seconds..."
    sleep ${STATUS_INTERVAL_SEC}
    wait_for_jobs_running
    wait_for_post_processor
    collect_results
}

# handler of cmd: run
parse_cmd_run() {

    local op_short
    local op_long
    op_short="hjw"
    op_long="jobs,watch,"

    # NOTE: This requires GNU getopt.
    if ! opts=$(getopt -n "${PROG_NAME}" -o "${op_short}" --long "${op_long}" -- "$@");
    then
        echo "gnu-getopt seems not to be present. Please install it. Terminating..." >&2 ;
        exit 1 ;
    fi
    eval set -- "${opts}"

    while true; do
        case "${1:-""}" in
            -h | --help  ) show_help; exit 2 ;;
            --timeout    ) RUN_TIMEOUT="$2" ; shift 2 ;;
            --watch | -w ) OPT_WATCH=true ; shift ;;
            --           ) shift; break ;;
        esac
    done

    cmd_run
}

# handler of cmd: results
parse_cmd_results() {
    cmd_results
}

# handler of cmd: retrieve
parse_cmd_retrieve() {
    cmd_retrieve
}

# handler of cmd: destroy
parse_cmd_destroy() {
    cmd_destroy
}

# handler of cmd: status
parse_cmd_status() {
    local op_short
    local op_long
    op_short="hw"
    op_long="watch,"

    # NOTE: This requires GNU getopt.
    if ! opts=$(getopt -n "${PROG_NAME}" -o "${op_short}" --long "${op_long}" -- "$@");
    then
        echo "gnu-getopt seems not to be present. Please install it. Terminating..." >&2 ;
        exit 1 ;
    fi
    eval set -- "${opts}"

    while true; do
        case "${1:-""}" in
            -h | --help  ) show_help; exit 2 ;;
            --watch | -w ) OPT_WATCH=true ; shift || true;;
            --           ) shift || true; break ;;
            *            ) echo "Option not found"; break ;;
        esac
    done
    cmd_status
}

#
# Main
#
parse_cmds() {
    if [[ -z "${KUBECONFIG:-}" ]]; then
        echo "ERROR: KUBECONFIG env var is not set.";
        exit 1;
    fi
    OPT_CMD="${1:-""}"; shift || true
    case ${OPT_CMD:-""} in
        "help"|"--help"     ) show_help; exit 0 ;;
        "run"               ) parse_cmd_run "$@" ;;
        "results"|"res"     ) parse_cmd_results "$@" ;;
        "retrieve"          ) parse_cmd_retrieve "$@" ;;
        "destroy"|"delete"  ) parse_cmd_destroy "$@" ;;
        "status"            ) parse_cmd_status "$@" ;;
        * ) echo "Option [${OPT_CMD:-}] not found."; show_help ;;
    esac
}

parse_cmds "$@"
