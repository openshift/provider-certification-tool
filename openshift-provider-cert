#!/usr/bin/env bash

#
# OCP cluster orchestrator and benchmark job runner.
# See helper function (show_help|-h) for more information.
#

set -o pipefail
set -o nounset
set -o errexit

#
# Globals
#
declare -gx OPT_CMD
declare -gx RUN_TIMEOUT
declare -gx STAT_FILE

STAT_FILE="/tmp/sonobuoy-status.json"

#
# Helper
#
show_help() {

    cat <<-EOF
Usage: ${0} command [options]
Available commands:
    help                        Show this help.
    run                         Run the suite of tests for provider certification.

Global options:
    -h | --help                 Show this help.

Available options for 'run':
    --timeout {number}          Optional. Timeout in minutes to
                                wait the execution. Default: 43200

Examples:
    # Run the Certification tool
    ${0} run

EOF

}

#
# cmd: Status
#

#
# cmd: Inspect
#

#
# cmd: Destroy
#


#
# cmd: Run
#
check_sonobuoy_is_present() {
    # Check if there's sonobuoy environment: should fail
    local ns
    ns="$(oc get projects |grep ^sonobuoy || true)"
    if [[ -n "${ns}" ]]; then
        echo "sonobuoy project is present on cluster. Run the destroy flow: ./destroy.sh"
        exit 1
    fi
}

set_scc() {
    echo "Ensuring the Tool will run in the privileged environment..."
    oc adm policy add-scc-to-group anyuid system:authenticated system:serviceaccounts
    oc adm policy add-scc-to-group privileged system:authenticated system:serviceaccounts
}

run_default() {
    echo "Running OpenShift Provider Certification Tool..."
    # Do not use timeout=0:
    # https://github.com/mtulio/openshift-provider-certification/issues/17
    PLUGIN_TIMEOUT=${RUN_TIMEOUT:-43200}
    sonobuoy run \
        --dns-namespace openshift-dns \
        --dns-pod-labels=dns.operator.openshift.io/daemonset-dns=default \
        --timeout "${PLUGIN_TIMEOUT}" \
        --plugin tools/plugins/openshift-kube-conformance.yaml \
        --plugin tools/plugins/openshift-provider-cert-level-1.yaml \
        --plugin tools/plugins/openshift-provider-cert-level-2.yaml \
        --plugin tools/plugins/openshift-provider-cert-level-3.yaml
    RC=$?
    if [[ ${RC} -ne 0 ]]; then
        echo "ERROR: error running the tool. Please check the errors and try again."
        exit ${RC}
    fi
    echo "$(date)> The certification tool is running, statuses will be reported every minute..."
}

run_status_updater() {
    sonobuoy status --json > "${STAT_FILE}" 2>/dev/null || true
}

show_status() {
    run_status_updater
    printf "\n\n$(date)> Global Status: %s" "$(jq -r '.status // "Unknown"' ${STAT_FILE})"
    printf "\n%-30s | %-10s | %-10s | %-25s | %-50s" \
            "JOB_NAME" "STATUS" "RESULTS" "PROGRESS" "MESSAGE"
    for plugin_name in $(jq -r '.plugins[].plugin' ${STAT_FILE} |sort); do
        pl_status=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\").status" "${STAT_FILE}")
        pl_result=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\")[\"result-status\"]" "${STAT_FILE}" | tr -d '\n')

        pl_prog_total=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\").progress.total // \"\"" "${STAT_FILE}" | tr -d '\n')
        pl_prog_comp=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\").progress.completed // \"\"" "${STAT_FILE}" | tr -d '\n')
        pl_prog_failed=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\").progress.failures|length" "${STAT_FILE}" | tr -d '\n')

        pl_progress=""
        if [[ -n "${pl_prog_total}" ]]; then
            pl_progress="${pl_prog_comp}/${pl_prog_total} (${pl_prog_failed} failures)"
        fi

        pl_count_pass=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\")[\"result-counts\"].passed" "${STAT_FILE}" | tr -d '\n')
        pl_count_fail=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\")[\"result-counts\"].failed" "${STAT_FILE}" | tr -d '\n')
        test "${pl_count_pass}" == "null" && pl_count_pass=0
        test "${pl_count_fail}" == "null" && pl_count_fail=0

        if [[ "${pl_status}" == "running" ]]; then
            pl_msg=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\") |.progress.msg // \"\"" "${STAT_FILE}" | tr -d '\n')
        elif [[ "${pl_result}" == "" ]]; then
            pl_msg="waiting post-processor..."
        else
            pl_msg="Total tests processed: $(echo "$pl_count_pass + $pl_count_fail "|bc) (${pl_count_pass} pass / ${pl_count_fail} failed)"
        fi

        printf "\n%-30s | %-10s | %-10s | %-25s | %-50s" \
                "${plugin_name}" "${pl_status}" "${pl_result}" \
                "${pl_progress}" "${pl_msg}"
    done
}

show_results_processor() {
    run_status_updater
    printf "\n\n$(date)> Global Status: %s" "$(jq -r '.status // "Unknown"' ${STAT_FILE})"
    printf "\n%-30s | %-10s | %-10s | %-50s" \
            "JOB_NAME" "STATUS" "RESULTS" "PROCESSOR RESULTS"
    for plugin_name in $(jq -r '.plugins[].plugin' ${STAT_FILE} |sort); do
        pl_status=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\").status" "${STAT_FILE}")
        pl_result=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\")[\"result-status\"]" "${STAT_FILE}" | tr -d '\n')

        pl_count_pass=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\")[\"result-counts\"].passed" "${STAT_FILE}" | tr -d '\n')
        pl_count_fail=$(jq -r ".plugins[] | select (.plugin==\"${plugin_name}\")[\"result-counts\"].failed" "${STAT_FILE}" | tr -d '\n')
        test "${pl_count_pass}" == "null" && pl_count_pass=0
        test "${pl_count_fail}" == "null" && pl_count_fail=0

        pl_msg="Total tests processed: $(echo "$pl_count_pass + $pl_count_fail "|bc) (${pl_count_pass} pass / ${pl_count_fail} failed)"

        printf "\n%-30s | %-10s | %-10s | %-50s" \
                "${plugin_name}" "${pl_status}" \
                "${pl_result}" "${pl_msg}"
    done
}

wait_for_jobs_running() {
    sleep 5 # waiting to leave from 'Pending' state
    echo "$(date)> The certification tool is running, statuses will be reported every minute..."
    while true; do
        run_status_updater
        if [[ "$(jq -r .status ${STAT_FILE})" != "running" ]]; then
            break
        fi
        show_status
        sleep 10
    done
    show_status
    echo -e "\n\n$(date)> Jobs has finished."
    sleep 5
    show_results_processor
}

wait_for_post_processor() {
    #TODO(): Create a fn show_results w/ custom fields of processor,
    # w/o PROGRESS field.
    #TODO(): there's a bug on kube-conformance suite with is crashing
    # the plugin, resulting in empty junit files. Report-progress should
    # report crashs like that w/ some insights on MSG aggregator field.

    echo -e "\nWaiting the post-processor to collect the results..."
    cnt=0
    while true; do
        run_status_updater
        if [[ "$(jq -r .status ${STAT_FILE})" != "post-processing" ]]; then
            break
        fi
        cnt=$(( cnt + 1 ))
        if [[ $cnt -eq 20 ]]; then
            echo -e "\n\n$(date)> Timeout waiting the result post-processor..."
            echo -e "\n\n$(date)> Run again with option 'check'"
            exit 1
        fi
        sleep 30
    done
}

collect_results() {
    echo -e "\n\nCollecting results..."
    sleep 10

    set +o errexit
    download_failed=true
    retries=0
    while ${download_failed}; do
        result_file=$(sonobuoy retrieve)
        RC=$?
        # TODO[1](release): need to collect artifacts if
        #  'sonobuoy retrieve' returned 'EOF' (download error).
        # https://github.com/mtulio/openshift-provider-certification/issues/4
        # TODO[2](asap): The filename could be set for 'retrieve' option,
        # so it can be an work arround while [1] is not fixed.
        if [[ ${RC} -eq 0 ]]; then
            download_failed=false
        fi
        retries=$(( retries + 1 ))
        if [[ $retries -eq 10 ]]; then
            echo "Retries timed out. Check 'sonobuoy retrieve' command."
            exit 1
        fi
        echo "Error retrieving results. Waiting 10s to retry...[${retries}/10]"
        sleep 10
    done
    set -o errexit

    if [[ -f ${result_file} ]]; then
        echo "Results saved at file ${result_file}"
        echo "Conformance runner has finished successfully."

        # Used by report.sh
        # TODO(pre-release): improve the result inspection.
        # TODO(asap): remove dependency of report.sh
        # https://github.com/mtulio/openshift-provider-certification/issues/16
        test -f .tmp/ && mv .tmp/ .tmp/old-"$(date +%Y%m%d%H%M%S)"
        test -f .tmp/ || mkdir -p .tmp/
        echo "${result_file}" > .tmp/latest-result.txt
        cp "${result_file}" ./.tmp/
        exit 0
    fi

    echo "Results file not found. Execution has finished with errors."
    exit 1
}

cmd_run() {
    echo "Starting OpenShift Provider Certification Tool..."

    check_sonobuoy_is_present
    set_scc
    run_default
    wait_for_jobs_running
    wait_for_post_processor
    collect_results
}

parse_cmd_run() {

    # NOTE: This requires GNU getopt.
    # '-> On Mac OS X and FreeBSD need to be installed as: brew install gnu-getopt
    if ! opts=$(getopt -n 'openshift-provider-cert' \
            -o hj \
            --long jobs, \
            -- "$@"); then
        echo "gnu-getopt seems not to be present. Please install it. Terminating..." >&2 ;
        exit 1 ;
    fi
    eval set -- "${opts}"

    while true; do
        case "$1" in
            -h | --help         ) show_help; exit 2 ;;
            --timeout           ) RUN_TIMEOUT="$2" ; shift 2 ;;
            -- ) shift; break ;;
            * ) echo "Option not found"; break ;;
        esac
    done

    if [[ -z "${KUBECONFIG:-}" ]]; then
        echo "ERROR: KUBECONFIG env var is not set.";
        exit 1;
    fi
    cmd_run
}

#
# Main
#
parse_cmds() {
    case ${1:-""} in
    "help"|"--help" ) show_help; exit 0 ;;
    "run"           ) OPT_CMD="$1"; shift; parse_cmd_run "$@";;
    *) echo "Command [${1:-}] not found"; show_help;;
    esac
}

parse_cmds "$*"
